/*
          # Comprehensive Popup, Chat, and Notification Fix
          This migration addresses several issues:
          1. Creates the `chat_groups` and `chat_participants` tables if they don't exist.
          2. Adds new columns to `city_popups` for enhanced features (price, gender, dating, etc.).
          3. Establishes the correct foreign key relationship between `city_popups` and `chat_groups`.
          4. Creates a function and trigger to notify city members about new popups.
          5. Adds columns to `chat_messages` to support image and location sharing.

          ## Query Description: "This operation will create and modify tables related to the community chat and popup features. It is designed to be safe to run, but as it alters table structures, a backup is always a good precaution."
          
          ## Metadata:
          - Schema-Category: "Structural"
          - Impact-Level: "Medium"
          - Requires-Backup: false
          - Reversible: false
          
          ## Structure Details:
          - Creates: `chat_groups`, `chat_participants`
          - Modifies: `city_popups`, `chat_messages`
          - Adds: `handle_new_popup_notification` function and trigger
          
          ## Security Implications:
          - RLS Status: Enabled on new tables.
          - Policy Changes: Adds RLS policies for chat functionality.
          - Auth Requirements: Policies are based on `auth.uid()`.
          
          ## Performance Impact:
          - Indexes: Adds foreign key indexes.
          - Triggers: Adds one AFTER INSERT trigger on `city_popups`.
          - Estimated Impact: Low impact on general performance, trigger fires only on new popup creation.
*/

-- Step 1: Create chat_groups table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.chat_groups (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    popup_id uuid,
    name text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE public.chat_groups ENABLE ROW LEVEL SECURITY;

-- Step 2: Create chat_participants table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.chat_participants (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    group_id uuid REFERENCES public.chat_groups(id) ON DELETE CASCADE,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE (group_id, user_id)
);
ALTER TABLE public.chat_participants ENABLE ROW LEVEL SECURITY;

-- Step 3: Add new columns to city_popups if they don't exist
DO $$
BEGIN
  IF NOT EXISTS(SELECT 1 FROM pg_type WHERE typname = 'gender_pref') THEN
    CREATE TYPE public.gender_pref AS ENUM ('all', 'females_only', 'males_only');
  END IF;
END$$;

ALTER TABLE public.city_popups
ADD COLUMN IF NOT EXISTS max_attendees integer DEFAULT 10 NOT NULL,
ADD COLUMN IF NOT EXISTS price integer,
ADD COLUMN IF NOT EXISTS gender_pref public.gender_pref DEFAULT 'all'::public.gender_pref,
ADD COLUMN IF NOT EXISTS allow_dating boolean DEFAULT false NOT NULL,
ADD COLUMN IF NOT EXISTS allow_friendship boolean DEFAULT true NOT NULL,
ADD COLUMN IF NOT EXISTS expires_at timestamp with time zone;

-- Step 4: Establish foreign key from chat_groups to city_popups
ALTER TABLE public.chat_groups
ADD COLUMN IF NOT EXISTS popup_id uuid;

ALTER TABLE public.chat_groups
DROP CONSTRAINT IF EXISTS chat_groups_popup_id_fkey;

ALTER TABLE public.chat_groups
ADD CONSTRAINT chat_groups_popup_id_fkey
FOREIGN KEY (popup_id) REFERENCES public.city_popups(id) ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_chat_groups_popup_id ON public.chat_groups(popup_id);

-- Step 5: Add columns to chat_messages for rich content
ALTER TABLE public.chat_messages
ADD COLUMN IF NOT EXISTS type text DEFAULT 'text'::text NOT NULL,
ADD COLUMN IF NOT EXISTS metadata jsonb;

-- Step 6: Create RLS policies for chat
CREATE POLICY "Allow read access to group members" ON public.chat_groups
FOR SELECT USING (
  id IN (
    SELECT group_id FROM public.chat_participants WHERE user_id = auth.uid()
  )
);

CREATE POLICY "Allow read access to participants" ON public.chat_messages
FOR SELECT USING (
  chat_id IN (
    SELECT group_id FROM public.chat_participants WHERE user_id = auth.uid()
  )
);

CREATE POLICY "Allow insert for group members" ON public.chat_messages
FOR INSERT WITH CHECK (
  auth.uid() = user_id AND chat_id IN (
    SELECT group_id FROM public.chat_participants WHERE user_id = auth.uid()
  )
);

CREATE POLICY "Allow members to see other members" ON public.chat_participants
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.chat_participants
    WHERE group_id = chat_participants.group_id AND user_id = auth.uid()
  )
);

-- Step 7: Create notification function and trigger
CREATE OR REPLACE FUNCTION public.handle_new_popup_notification()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  city_name text;
BEGIN
  -- Get the city name
  SELECT name INTO city_name FROM public.cities WHERE id = NEW.city_id;

  -- Insert a notification for each user who has joined that city
  INSERT INTO public.notifications (user_id, title, message, type, metadata)
  SELECT
    user_id,
    'New Popup in ' || city_name,
    '"' || NEW.title || '" just started. Join the conversation!',
    'info',
    json_build_object('popup_id', NEW.id, 'city_id', NEW.city_id)
  FROM public.user_joined_cities
  WHERE city_id = NEW.city_id AND user_id != NEW.creator_id;

  RETURN NEW;
END;
$$;

-- Create the trigger on the city_popups table
DROP TRIGGER IF EXISTS on_new_popup ON public.city_popups;
CREATE TRIGGER on_new_popup
AFTER INSERT ON public.city_popups
FOR EACH ROW
EXECUTE FUNCTION public.handle_new_popup_notification();
